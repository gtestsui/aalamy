<?php

namespace Modules\QuestionBank\Models;

use App\Exceptions\ErrorMsgException;
use App\Http\Controllers\Classes\ApplicationModules;
use App\Http\Traits\DefaultGlobalScopes;

use App\Http\Traits\Searchable;
use App\Http\Traits\SoftDelete;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\Relation;
use Modules\QuestionBank\Traits\ModelRelations\QuestionBank\QuestionBankRelations;

class QuestionBank extends Model
{
    use DefaultGlobalScopes;
    use HasFactory;
    use SoftDelete;
    use Searchable;
    use QuestionBankRelations;

    protected $table = 'question_banks';

    public static function customizedBooted(){}

//
//    public function __call($method, $parameters)
//    {
////
////        $reflector = new \ReflectionClass(get_called_class());
////
////         dd(collect($reflector->getMethods())
////            ->filter(
////                fn($method) => !empty($method->getReturnType()) &&
////                    str_contains(
////                        $method->getReturnType(),
////                        'Illuminate\Database\Eloquent\Relations'
////                    )
////            )
////            ->pluck('name')
////            ->all());
//
//
//
//        if(str_contains($method,'EvenItsDeleted'))
//            dd('true');
//
//
//
//
//        $class = new \ReflectionClass($this);
//        $methods = $class->getMethods(\ReflectionMethod::IS_PUBLIC);
//
////        dd(get_class_methods($this));
//        return parent::__call($method, $parameters); // TODO: Change the autogenerated stub
//    }




    protected $fillable=[
        'question',
        'question_type',
        'shared_with_library',//when the item updated then shared_with_library will reset to default false and can share it again
        'difficult_level',
        'school_id',
        'educator_id',
        'teacher_id',
        'level_subject_id',
        'unit_id',
        'lesson_id',
        'deleted',
        'deleted_by_cascade',
        'deleted_at',
    ];

    /**
     * @var string[] $relationsSoftDelete
     * its contain our relations name but not all relations
     * just the relations we want it to delete by cascade while using softDelete
     */
    protected $relationsSoftDelete = [
        'FillInBlanks',
        'FillTexts',
        'JumbleSentences',
        'MatchingLeftList',
        'MatchingRightList',
        'MultiChoices',
        'Ordering',
        'TrueFalse',
        'QuizQuestions',

    ];

    private $mySearchableFields = [
        'question',
        'question_type',
    ];

    //Attributes



    //Scopes
    public function markAsShared($status=true){
        return $this->update([
            'shared_with_library'=>$status
        ]);
    }

    public function isShared(){
        return $this->shared_with_library;
    }

    public function scopeFilterMyQuestionBank($query,?array $filter=null){
        if(is_null($filter) || !count($filter))
            return $query;

        $query->when(isset($filter['search_key']),function ($query)use ($filter){
                return $query->search($filter['search_key']);
            })->when(isset($filter['question_type']),function ($query)use ($filter){
                return $query->where('question_type',$filter['question_type']);
            })
            ->when(isset($filter['level_id']),function ($query)use ($filter){
                return $query->whereHas('LevelSubject',function ($query)use ($filter){
                    return $query->where('level_id',$filter['level_id']);
                });
            })
            ->when(isset($filter['level_subject_id']),function ($query)use ($filter){
                return $query->where('level_subject_id',$filter['level_subject_id']);
            })
            ->when(isset($filter['unit_id']),function ($query)use ($filter){
                return $query->where('unit_id',$filter['unit_id']);
            })
            ->when(isset($filter['lesson_id']),function ($query)use ($filter){
                return $query->where('lesson_id',$filter['lesson_id']);
            })

            ->when(isset($filter['unit_ids']),function ($query)use ($filter){
                return $query->whereIn('unit_id',$filter['unit_ids']);
            })
            ->when(isset($filter['lesson_ids']),function ($query)use ($filter){
                return $query->whereIn('lesson_id',$filter['lesson_ids']);
            })

            ->when(isset($filter['difficult_levels']),function ($query)use ($filter){
                return $query->whereIn('difficult_level',$filter['difficult_levels']);
            });
        return $query;
    }

    public function scopeWithAllQuestionTypes($query){
        return $query->with(array_values(
            configFromModule(
                'panel.question_types_relations',ApplicationModules::QUESTION_BANK_MODULE_NAME
            )
        ));

        /*return $query->with([
            'FillInBlanks',
            'FillTexts',
            'JumbleSentences',
            'MatchingLeftList.RightListRecords',
            'MultiChoices',
            'Ordering',
            'TrueFalse'
        ]);*/
    }


    public function scopeWithAllQuestionTypesForStudentQuiz($query){
        return $query->with([
//            'FillInBlanks',
//            'FillTexts',
            'JumbleSentences',
            'MatchingLeftList',
            'MatchingRightList',
            'MultiChoices',
            'Ordering',
//            'TrueFalse'
        ]);
    }


    public function scopeWithDefinedQuestionType($query,$questionType){
        if(!isset($questionType))
            return $query;

        if(!in_array($questionType,configFromModule('panel.question_types',ApplicationModules::QUESTION_BANK_MODULE_NAME)))
            throw new ErrorMsgException('invalid question type');


        return $query->with(configFromModule('panel.question_types_relations.'.$questionType,ApplicationModules::QUESTION_BANK_MODULE_NAME));

    }



}
